<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linuxRAID</title>
      <link href="/2024/09/13/linuxRAID/"/>
      <url>/2024/09/13/linuxRAID/</url>
      
        <content type="html"><![CDATA[<p>系统中的软 RAID 和硬 RAID 是两种不同的 RAID (Redundant Array of Independent Disks) 实现方式，用于提高数据存储的性能、冗余和可靠性。它们的主要区别在于 RAID 的管理方式、性能和硬件依赖性。</p><ol><li>软 RAID (Software RAID)<br>软 RAID 是通过操作系统的软件来实现 RAID 功能的，无需专用的硬件 RAID 控制器。</li></ol><ul><li>实现方式<br>：软 RAID 依赖于操作系统的驱动程序和 CPU 来执行 RAID 逻辑。它通过软件层进行管理，常见的工具如 Linux 中的 mdadm 可以创建和管理软 RAID。</li><li>优点<br>：</li><li>成本低：无需专门的 RAID 硬件，使用现有的硬盘和 CPU 资源即可实现 RAID 功能。</li><li>灵活性高：几乎所有类型的 RAID（如 RAID 0、RAID 1、RAID 5、RAID 10 等）都可以通过软件配置，且与硬件无关。</li><li>易于配置：可以通过操作系统命令轻松管理 RAID 阵列。</li><li>缺点<br>：</li><li>性能较差：软 RAID 依赖系统的 CPU 来处理 RAID 操作，这会消耗一定的系统资源，特别是在高负载或复杂 RAID 类型（如 RAID 5、RAID 6）下。</li><li>受限于操作系统：需要操作系统支持，可能在不同的操作系统中实现不一致。</li></ul><ol start="2"><li>硬 RAID (Hardware RAID)<br>硬 RAID 是通过专用的 RAID 控制器（硬件卡）来管理和实现 RAID 功能。硬件 RAID 卡上通常有独立的处理器和内存，用于处理 RAID 操作。</li></ol><ul><li>实现方式<br>：硬 RAID 使用独立的 RAID 控制器管理所有 RAID 操作，这些控制器有自己的处理器，独立于系统 CPU，且可以处理磁盘之间的所有数据交互。</li><li>优点<br>：</li><li>性能更好：由于 RAID 操作由专用硬件处理，不会占用系统 CPU，因此性能更高，特别是在高负载环境下。</li><li>更好的数据保护：硬 RAID 卡通常带有电池备份和缓存功能，以防止数据丢失。</li><li>操作系统无关：硬件 RAID 对操作系统透明，操作系统只会看到一个逻辑磁盘，硬 RAID 在系统启动时即可生效。</li><li>缺点<br>：</li><li>成本高：需要购买专用的 RAID 控制器，硬 RAID 卡可能价格较高，特别是支持更多磁盘和高性能的卡。</li><li>兼容性问题：不同厂商的 RAID 控制器可能有不同的驱动程序和管理工具，存在兼容性问题。</li><li>维护复杂：硬 RAID 的设置和故障排查可能需要专门的工具和知识。</li></ul><ol start="3"><li>对比<br>特性软 RAID硬 RAID实现方式通过操作系统实现通过专用硬件控制器实现成本低，使用现有系统资源高，需要购买专用硬件性能依赖于 CPU 和系统资源高，专用处理器处理 RAID 逻辑系统资源占用高，占用 CPU 和内存低，不占用系统资源数据安全由操作系统和软件负责硬件控制器有额外的数据保护功能灵活性高，易于配置和更改较低，依赖硬件设置<br>总结</li></ol><ul><li>软 RAID 适用于对性能要求不高、预算有限的场景，或者当不需要额外硬件时。</li><li>硬 RAID 则适用于高性能、高可靠性、对数据保护有更高需求的场景，比如服务器或数据中心。</li></ul><p>RAID 是一种用于管理和组织多个硬盘的方法，以实现性能提升或数据冗余。不同的 RAID 级别提供不同的性能、数据保护和存储效率。下面简要介绍几种常见的 RAID 级别：</p><ol><li>RAID 0（条带化）<br>RAID 0 将数据分成块，然后在多个磁盘上并行存储。它没有冗余或数据保护机制，但可以显著提升读写速度。</li></ol><ul><li>数据保护：无</li><li>优点：高速的读写性能，尤其适合需要高吞吐量的应用程序。</li><li>缺点：没有数据冗余，任何一块磁盘损坏，整个阵列的数据都会丢失。</li><li>存储效率：100%（n 块磁盘可用 n 倍容量）</li></ul><ol start="2"><li>RAID 1（镜像）<br>RAID 1 是最简单的冗余形式。它将同一份数据完整地复制到两个或更多磁盘上。每个磁盘都保存完整的副本，因此具有较高的容错能力。</li></ol><ul><li>数据保护：非常高，只要有一个磁盘完好，数据就安全。</li><li>优点：高度的数据安全性，读取性能提升（因为可以同时从两个磁盘读取）。</li><li>缺点：存储效率低，存储成本较高，因为两个磁盘保存相同的数据。</li><li>存储效率：50%（n 块磁盘中仅有 n&#x2F;2 的容量可用）</li></ul><ol start="3"><li>RAID 3（带有奇偶校验的字节级条带化）<br>RAID 3 使用字节级条带化，并在一个专用磁盘上保存奇偶校验数据。每次写入操作会更新奇偶校验磁盘，以确保当数据磁盘故障时可以通过奇偶校验数据恢复数据。</li></ol><ul><li>数据保护：允许一个磁盘故障，数据仍可恢复。</li><li>优点：提供容错，写入性能较好，适合连续的大量数据传输。</li><li>缺点：奇偶校验磁盘成为单点瓶颈，写入时需要更新奇偶校验。</li><li>存储效率：(n-1)&#x2F;n（n 块磁盘，1 块用于奇偶校验）</li></ul><ol start="4"><li>RAID 5（带有奇偶校验的块级条带化）<br>RAID 5 是最常用的 RAID 级别之一，它使用块级条带化，并在多个磁盘上分布保存奇偶校验数据。与 RAID 3 不同，RAID 5 并不需要单独的奇偶校验磁盘，而是将奇偶校验块均匀分布在所有磁盘上。</li></ol><ul><li>数据保护：允许一个磁盘故障，数据仍可恢复。</li><li>优点：读写性能较好，提供冗余和较高的存储效率。</li><li>缺点：写入时需要计算和更新奇偶校验，写性能稍差，尤其是小文件写入。</li><li>存储效率：(n-1)&#x2F;n（n 块磁盘，1 块相当于用于奇偶校验）</li></ul><ol start="5"><li>RAID 6（带有双奇偶校验的块级条带化）<br>RAID 6 类似于 RAID 5，但它使用两个奇偶校验块，这使得它能够在任意两个磁盘同时故障时仍能恢复数据。奇偶校验数据分布在所有磁盘上。</li></ol><ul><li>数据保护：允许最多两个磁盘故障，数据仍可恢复。</li><li>优点：高度的数据安全性，尤其适合大容量磁盘阵列，双奇偶校验防止多块磁盘故障。</li><li>缺点：写入时的计算复杂度更高，写性能低于 RAID 5，特别是小文件写入时。</li><li>存储效率：(n-2)&#x2F;n（n 块磁盘，2 块用于奇偶校验）</li></ul><ol start="6"><li>RAID 10（RAID 1+0，镜像和条带化）<br>RAID 10 是 RAID 1 和 RAID 0 的组合。它先做 RAID 1（镜像），然后在多个镜像对上做 RAID 0（条带化）。RAID 10 提供了 RAID 0 的性能和 RAID 1 的冗余。</li></ol><ul><li>数据保护：允许每组 RAID 1 中一个磁盘故障，提供较高的数据冗余和容错能力。</li><li>优点：读取和写入性能都很好，容错能力高。</li><li>缺点：存储效率较低，磁盘数量必须为偶数，且存储效率为 50%。</li><li>存储效率：50%（n 块磁盘中仅有 n&#x2F;2 的容量可用）</li></ul><ol start="7"><li>RAID 50（RAID 5+0）<br>RAID 50 是 RAID 5 和 RAID 0 的组合，先做 RAID 5 再在多个 RAID 5 阵列上做 RAID 0。它结合了 RAID 5 的冗余和 RAID 0 的性能。</li></ol><ul><li>数据保护：允许每个 RAID 5 阵列中一个磁盘故障。</li><li>优点：提供 RAID 5 的冗余以及 RAID 0 的读写性能提升。</li><li>缺点：相比 RAID 5 需要更多磁盘，配置复杂度较高。</li><li>存储效率：依赖于 RAID 5 配置</li></ul><ol start="8"><li>RAID 60（RAID 6+0）<br>RAID 60 是 RAID 6 和 RAID 0 的组合，先做 RAID 6 再在多个 RAID 6 阵列上做 RAID 0，提供双重冗余和高性能。</li></ol><ul><li>数据保护：允许每个 RAID 6 阵列中最多两个磁盘故障。</li><li>优点：更高的数据安全性和可靠性，以及 RAID 0 提供的性能提升。</li><li>缺点：配置复杂度和成本较高，写性能会因为 RAID 6 的双奇偶校验受到影响。</li><li>存储效率：依赖于 RAID 6 配置<br>总结<br>不同的 RAID 级别适合不同的应用场景：</li><li>RAID 0：用于需要高性能但不关心数据安全性的场景。</li><li>RAID 1：适合需要高数据安全性，且存储容量要求不高的场景。</li><li>RAID 5 和 RAID 6：适合需要较高读写性能，同时需要数据冗余的企业环境。</li><li>RAID 10：适合需要高性能和高容错的高端应用，例如数据库或关键业务系统。<br>每种 RAID 级别在性能、数据安全和存储效率之间取得不同的平衡。选择适合的 RAID 类型应根据存储需求、可用的磁盘数量、性能要求和数据安全级别进行综合考虑。</li></ul><p>冗余度 是指在 RAID 等数据存储系统中，系统通过额外的磁盘或数据副本来保护数据的一种方式，确保在硬件故障（如磁盘损坏）时系统仍能继续运行并保持数据完整性。不同的 RAID 级别提供不同的冗余方式，主要通过数据镜像、奇偶校验等手段来实现。<br>冗余度的理解：</p><ul><li>高冗余度：表示系统具有更强的故障容忍能力，允许更多磁盘故障而不会丢失数据。例如，RAID 1（镜像）和 RAID 6（双奇偶校验）都提供较高的冗余度。</li><li>低冗余度：表示系统容忍磁盘故障的能力较弱，甚至没有冗余保护。比如 RAID 0 没有任何冗余，一块磁盘故障就会导致整个系统的数据丢失。<br>冗余度举例：</li><li>RAID 1（镜像）：每个磁盘都有一个完整的副本（镜像），因此冗余度为 1。也就是说，即使一块磁盘故障，仍然可以从镜像中恢复数据。</li><li>RAID 5：通过奇偶校验在多个磁盘上分布存储数据，冗余度允许一个磁盘故障，且能够通过奇偶校验恢复数据。</li><li>RAID 6：类似 RAID 5，但增加了双重奇偶校验，允许两个磁盘同时故障的情况下仍可恢复数据，冗余度更高。<br>热备盘 (Hot Spare Disk) 的概念：<br>热备盘 是一种专用磁盘，虽然它没有参与 RAID 的正常读写操作，但在 RAID 阵列中的某个磁盘发生故障时，它会自动接替故障的磁盘，成为 RAID 阵列的一部分，立即开始数据重建过程。这种机制可以大幅缩短故障恢复的时间，提升系统的可靠性。<br>热备盘的工作原理：<br>1.RAID 阵列中某个磁盘发生故障时，系统会自动检测到这个故障。<br>2.热备盘自动替换这个故障磁盘，接管其工作。<br>3.RAID 系统会开始重建数据，将原本损坏磁盘中的数据重建到热备盘上（利用镜像、奇偶校验等方法）。<br>4.系统在数据恢复后继续正常运行，无需人工干预。<br>热备盘的分类：</li><li>本地热备盘（Local Hot Spare）：仅为一个特定的 RAID 阵列服务，当该阵列中的某个磁盘故障时，热备盘会立即生效。</li><li>全局热备盘（Global Hot Spare）：可以服务于多个 RAID 阵列，当任何一个阵列的磁盘发生故障时，热备盘都会自动接替故障磁盘的工作。<br>冗余度与热备盘的关系：</li><li>冗余度 指的是 RAID 系统能够容忍的磁盘故障数量。例如 RAID 5 允许一个磁盘故障，RAID 6 允许两个磁盘故障。</li><li>热备盘 提高了 RAID 系统的自动故障恢复能力，但不影响冗余度。它的作用是在磁盘故障时，快速替代故障磁盘并启动数据重建，从而减少阵列暴露在“降低冗余度”的时间内。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> raid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker挂载本机目录</title>
      <link href="/2024/09/11/docker%E6%8C%82%E8%BD%BD%E6%9C%AC%E6%9C%BA%E7%9B%AE%E5%BD%95/"/>
      <url>/2024/09/11/docker%E6%8C%82%E8%BD%BD%E6%9C%AC%E6%9C%BA%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h1><h2 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h2><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P \</span></span><br><span class="line"><span class="language-bash">    --name web \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html \</span></span></span><br><span class="line"><span class="language-bash">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \</span></span><br><span class="line"><span class="language-bash">    nginx:alpine</span></span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P \</span></span><br><span class="line"><span class="language-bash">    --name web \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html:ro \</span></span></span><br><span class="line"><span class="language-bash">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class="built_in">readonly</span> \</span></span><br><span class="line"><span class="language-bash">    nginx:alpine</span></span><br></pre></td></tr></table></figure><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/nginx/html # touch new.txt</span><br><span class="line">touch: new.txt: Read-only file system</span><br></pre></td></tr></table></figure><h2 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h2><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect web</span></span><br></pre></td></tr></table></figure><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/src/webapp&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h2 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h2><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> -it \</span></span><br><span class="line"><span class="language-bash">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span></span><br><span class="line"><span class="language-bash">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span></span><br><span class="line"><span class="language-bash">   ubuntu:18.04 \</span></span><br><span class="line"><span class="language-bash">   bash</span></span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/# history</span><br><span class="line">1  ls</span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p>]]></content>
      
      
      <categories>
          
          <category> docker学习,mount </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker数据卷</title>
      <link href="/2024/09/11/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
      <url>/2024/09/11/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>&#96;数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UnionFS，可以提供很多有用的特性：</p><ul><li>&#96;数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>&#96;数据卷默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：&#96;数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><h2 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h2><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume create my-vol</span></span><br></pre></td></tr></table></figure><p>查看所有的 <code>数据卷</code></p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br><span class="line"></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure><p>在主机里使用以下命令可以查看指定数据卷的信息</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume inspect my-vol</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h2><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -P \</span></span><br><span class="line"><span class="language-bash">    --name web \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># -v my-vol:/usr/share/nginx/html \</span></span></span><br><span class="line"><span class="language-bash">    --mount <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html \</span></span><br><span class="line"><span class="language-bash">    nginx:alpine</span></span><br></pre></td></tr></table></figure><h2 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h2><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker inspect web</span></span><br></pre></td></tr></table></figure><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h2 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h2><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume <span class="built_in">rm</span> my-vol</span></span><br></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker volume prune</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker仓库</title>
      <link href="/2024/09/11/docker%E4%BB%93%E5%BA%93/"/>
      <url>/2024/09/11/docker%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h1><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p>本节介绍如何使用本地仓库。</p><p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p><h2 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h2><h3 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h3><p>你可以使用官方 <code>registry</code> 镜像来运行。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 5000:5000 --restart=always --name registry registry</span></span><br></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d \</span></span><br><span class="line"><span class="language-bash">    -p 5000:5000 \</span></span><br><span class="line"><span class="language-bash">    -v /opt/data/registry:/var/lib/registry \</span></span><br><span class="line"><span class="language-bash">    registry</span></span><br></pre></td></tr></table></figure><h2 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h2><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker push 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:5000/v2/_catalog</span></span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><p>复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">rm</span> 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull 127.0.0.1:5000/ubuntu:latest</span></span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker image <span class="built_in">ls</span></span></span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><h2 id="配置非-https-仓库地址"><a href="#配置非-https-仓库地址" class="headerlink" title="配置非 https 仓库地址"></a>配置非 https 仓库地址</h2><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><h3 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h3><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><p>复制</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;192.168.199.100:5000&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keepalived：Nginx高可用的实现及抢占式与非抢占模式详解</title>
      <link href="/2024/08/12/keepalived/"/>
      <url>/2024/08/12/keepalived/</url>
      
        <content type="html"><![CDATA[<h1 id="Keepalived：Nginx高可用的实现及抢占式与非抢占模式详解"><a href="#Keepalived：Nginx高可用的实现及抢占式与非抢占模式详解" class="headerlink" title="Keepalived：Nginx高可用的实现及抢占式与非抢占模式详解"></a>Keepalived：Nginx高可用的实现及抢占式与非抢占模式详解</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Keepalived 是一种用于实现高可用性的工具，通过提供虚拟 IP（VIP），允许两个或多个服务器共享同一个 IP 地址，当一台服务器故障时，另一台服务器可以立即接管，确保服务的持续可用性。</p><h2 id="2-Keepalived-安装"><a href="#2-Keepalived-安装" class="headerlink" title="2. Keepalived 安装"></a>2. Keepalived 安装</h2><p>在 CentOS&#x2F;RHEL 系统上，可以通过以下命令安装 Keepalived：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install keepalived -y</span><br></pre></td></tr></table></figure><h2 id="3-Keepalived抢占式配置"><a href="#3-Keepalived抢占式配置" class="headerlink" title="3. Keepalived抢占式配置"></a>3. Keepalived抢占式配置</h2><h3 id="3-1-Keepalived抢占式MASTER配置"><a href="#3-1-Keepalived抢占式MASTER配置" class="headerlink" title="3.1 Keepalived抢占式MASTER配置"></a>3.1 Keepalived抢占式MASTER配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">  script <span class="string">&quot;/usr/local/bin/check_nginx.sh&quot;</span></span><br><span class="line">  interval 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">  state MASTER</span><br><span class="line">  interface eth0</span><br><span class="line">  virtual_router_id 51</span><br><span class="line">  priority 100</span><br><span class="line">  advert_int 1</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass 12345</span><br><span class="line">  &#125;</span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    192.168.0.100</span><br><span class="line">  &#125;</span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_nginx</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 默认抢占模式，不需要额外设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Keepalived抢占式BACKUP配置"><a href="#3-2-Keepalived抢占式BACKUP配置" class="headerlink" title="3.2 Keepalived抢占式BACKUP配置"></a>3.2 Keepalived抢占式BACKUP配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">  script <span class="string">&quot;/usr/local/bin/check_nginx.sh&quot;</span></span><br><span class="line">  interval 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">  state BACKUP</span><br><span class="line">  interface eth0</span><br><span class="line">  virtual_router_id 51</span><br><span class="line">  priority 90</span><br><span class="line">  advert_int 1</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass 12345</span><br><span class="line">  &#125;</span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    192.168.0.100</span><br><span class="line">  &#125;</span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_nginx</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># 默认抢占模式，不需要额外设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Keepalived非抢占式配置"><a href="#4-Keepalived非抢占式配置" class="headerlink" title="4 Keepalived非抢占式配置"></a>4 Keepalived非抢占式配置</h2><h2 id="4-1-Keepalived非抢占式MASTER配置"><a href="#4-1-Keepalived非抢占式MASTER配置" class="headerlink" title="4.1 Keepalived非抢占式MASTER配置"></a>4.1 Keepalived非抢占式MASTER配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">  state BACKUP</span><br><span class="line">  interface eth0</span><br><span class="line">  virtual_router_id 51</span><br><span class="line">  priority 100</span><br><span class="line">  advert_int 1</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass 12345</span><br><span class="line">  &#125;</span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    192.168.0.100</span><br><span class="line">  &#125;</span><br><span class="line">  nopreempt  <span class="comment"># 禁用抢占模式</span></span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_nginx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-Keepalived非抢占式BACKUP配置"><a href="#4-2-Keepalived非抢占式BACKUP配置" class="headerlink" title="4.2 Keepalived非抢占式BACKUP配置"></a>4.2 Keepalived非抢占式BACKUP配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">  state BACKUP</span><br><span class="line">  interface eth0</span><br><span class="line">  virtual_router_id 51</span><br><span class="line">  priority 90</span><br><span class="line">  advert_int 1</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass 12345</span><br><span class="line">  &#125;</span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    192.168.0.100</span><br><span class="line">  &#125;</span><br><span class="line">  nopreempt  <span class="comment"># 禁用抢占模式</span></span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_nginx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-启用并启动-Keepalived"><a href="#5-启用并启动-Keepalived" class="headerlink" title="5. 启用并启动 Keepalived"></a>5. 启用并启动 Keepalived</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start keepalived</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> keepalived</span><br></pre></td></tr></table></figure><h2 id="6-测试配置"><a href="#6-测试配置" class="headerlink" title="6. 测试配置"></a>6. 测试配置</h2><h3 id="6-1-故障转移测试"><a href="#6-1-故障转移测试" class="headerlink" title="6.1 故障转移测试"></a>6.1 故障转移测试</h3><p>   在主节点上停止 Nginx：sudo systemctl stop nginx。<br>   检查 VIP 是否转移到备用节点。</p><h3 id="6-2-恢复测试"><a href="#6-2-恢复测试" class="headerlink" title="6.2 恢复测试"></a>6.2 恢复测试</h3><p>   重新启动主节点上的 Nginx：sudo systemctl start nginx。<br>   检查 VIP 是否回到主节点（针对抢占模式）。</p><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>   通过 Keepalived，您可以实现高可用的 Nginx 集群。在抢占式模式下，主节点恢复后会重新获得 VIP，而在非抢占模式下，VIP 将继续保持在备节点，直到其停止运行。根据业务需求选择合适的模式，确保系统的高可用性和稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> 基础设施 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keepalived </tag>
            
            <tag> Nginx </tag>
            
            <tag> 高可用性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/06/hello-world/"/>
      <url>/2024/08/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
